# O(log n) - Logarithmic Time Complexity
- An algorithm has a logarithmic time complexity of O(log n) if its runtime grows logarithmically with the input size. This means that if the input size doubles, the runtime increases by a constant amount.

```swift
// Example of O(log n) time complexity: LogFunction recursive algorithm
func logFunction(n: Int) -> Int {
    if n <= 1 {
        return 0
    }
    return 1 + logFunction(n: n / 2)
}

logFunction(n: 8) // Output: 3
```
- In this example, the `logFunction` function takes an integer `n` as input and recursively calculates the logarithm base 2 of `n`. The time complexity is O(log n) because the function divides `n` by 2 in each recursive call, leading to a logarithmic number of operations relative to the input size.
- Steps:
1. Start with `n = 8`.
2. First call: `logFunction(8)` → `1 + logFunction(4)`
3. Second call: `logFunction(4)` → `1 + logFunction(2)`
4. Third call: `logFunction(2)` → `1 + logFunction(1)`
5. Fourth call: `logFunction(1)` → `0` (base case reached)
- Total operations: 1 (for n=8) + 1 (for n=4) + 1 (for n=2) + 0 (for n=1) = 3 operations, which corresponds to O(log n) time complexity.

## For non recursive algorithms
- An example of a non-recursive algorithm with O(log n) time complexity is binary search. Binary search efficiently finds the position of a target value within a sorted array by repeatedly dividing the search interval in half.

```c++
int binarySearch(int arr[], int target, int left, int right) {
    while (left <= right) {
        int mid = left + (right - left) / 2; // Calculate the middle index
        if (arr[mid] == target) {
            return mid; // Target found at index mid
        } else if (arr[mid] < target) {
            left = mid + 1; // Search in the right half
        } else {
            right = mid - 1; // Search in the left half
        }
    }
    return -1; // Target not found
}
```
- In this example, the `binarySearch` function takes a sorted list of integers `arr` and a `target` integer as input. It uses a while loop to repeatedly divide the search interval in half until it finds the target or determines that it is not present in the array. The time complexity is O(log n) because with each iteration, the search space is halved, leading to a logarithmic number of operations relative to the input size.