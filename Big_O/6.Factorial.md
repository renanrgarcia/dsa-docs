# O(n!) - Factorial Time Complexity
- An algorithm has a factorial time complexity of O(n!) if its runtime grows factorially with the input size. This means that if the input size increases by one, the runtime multiplies by the new input size.

```c#
void factorialAlgorithm(int n) {
    if (n == 0) {
        Console.WriteLine("***********");
        return;
    }
    for (int i = 0; i < n; i++) { // O(n)
        factorialAlgorithm(n - 1); // O((n-1)!)
    }
}
```

## Example of O(n!) time complexity: Permutations algorithm
- The `permute` function generates all possible permutations of a given array of numbers. The time complexity is O(n!) because:
  - For the first element, there are n choices.
  - For the second element, there are (n-1) choices.
  - For the third element, there are (n-2) choices, and so on.
  - Therefore, the total number of permutations is n * (n-1) * (n-2) * ... * 1 = n!, leading to a factorial time complexity.
```ts
// Example of O(n!) time complexity: Permutations algorithm
function permute(nums: number[]): number[][] {
    const result: number[][] = [];
    
    function backtrack(start: number) {
        if (start === nums.length) {
            result.push([...nums]);
            return;
        }
        for (let i = start; i < nums.length; i++) {
            [nums[start], nums[i]] = [nums[i], nums[start]]; // Swap
            backtrack(start + 1); // Recurse with the next index
            [nums[start], nums[i]] = [nums[i], nums[start]]; // Swap back
        }
    }
    
    backtrack(0);
    return result;
}
```