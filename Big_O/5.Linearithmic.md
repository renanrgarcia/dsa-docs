# O(n log n) - Linearithmic Time Complexity
- An algorithm has a linearithmic time complexity of O(n log n) if its runtime grows proportionally to the product of the input size and the logarithm of the input size. This is common in efficient sorting algorithms like merge sort and heap sort.

```python
def nLogn_algorithm(n):
    y = n
    while y > 1: # O(log n)
        y = y // 2
        for i in range(n): # O(n)
            print(i)
```

- In this example, the `nLogn_algorithm` function takes an integer `n` as input. The outer while loop runs O(log n) times because it divides `y` by 2 in each iteration until `y` is no longer greater than 1. The inner for loop runs O(n) times for each iteration of the while loop. Therefore, the overall time complexity of the algorithm is O(n log n) because we multiply the time complexities of the two loops together.

## Example of O(n log n) time complexity: MergeSort algorithm
```swift
// Example of O(n log n) time complexity: MergeSort algorithm
func mergeSort(_ array: [Int]) -> [Int] {
    if array.count <= 1 {
        return array
    }
    let mid = array.count / 2
    let left = mergeSort(Array(array[0..<mid]))
    let right = mergeSort(Array(array[mid..<array.count]))
    return merge(left, right)
}

func merge(_ left: [Int], _ right: [Int]) -> [Int] {
    var leftIndex = 0
    var rightIndex = 0
    var mergedArray: [Int] = []
    
    while leftIndex < left.count && rightIndex < right.count {
        if left[leftIndex] < right[rightIndex] {
            mergedArray.append(left[leftIndex])
            leftIndex += 1
        } else {
            mergedArray.append(right[rightIndex])
            rightIndex += 1
        }
    }
    
    while leftIndex < left.count {
        mergedArray.append(left[leftIndex])
        leftIndex += 1
    }
    
    while rightIndex < right.count {
        mergedArray.append(right[rightIndex])
        rightIndex += 1
    }
    
    return mergedArray
}
```
- In this example, the `mergeSort` function recursively divides an array into halves until each subarray contains only one element. Then, it merges these subarrays back together in sorted order using the `merge` helper function. The time complexity is O(n log n) because:
  - The recursion depth is O(log n) since we divide the array in half at each level.
  - At each level, merging takes O(n) time.
  - Therefore, the total time complexity is O(n log n).